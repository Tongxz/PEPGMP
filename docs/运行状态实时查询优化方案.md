# 运行状态实时查询优化方案

## 🎯 问题分析

### 当前存在的问题

1. **启动反馈不准确**
   ```
   用户点击"启动" → 立即显示"启动成功"
   ❌ 问题: 只是发送了启动命令，没有验证进程是否真正启动
   ```

2. **运行状态静态显示**
   ```typescript
   // 当前代码（第445行）
   return h(NTag, { type: 'default' }, { default: () => '⚪ 已停止' })
   // ❌ 问题: 写死的状态，不是实时查询
   ```

3. **状态不同步**
   ```
   实际情况: 进程已启动
   界面显示: ⚪ 已停止
   ❌ 问题: 用户看到的不是真实状态
   ```

---

## 💡 解决方案

### 方案概述

1. **在Camera接口中添加运行状态字段**
2. **定期查询所有摄像头的运行状态**
3. **启动后验证进程是否真正运行**
4. **实时更新UI显示**

---

## 🛠️ 实施步骤

### 步骤1: 扩展Camera类型定义

```typescript
// frontend/src/api/camera.ts
export interface Camera {
  id: string
  name: string
  source: string
  active?: boolean
  auto_start?: boolean
  // ... 其他字段
  
  // 新增: 运行时状态（由前端查询后填充）
  runtime_status?: {
    running: boolean
    pid?: number
    fps?: number
    last_update?: string
  }
}
```

### 步骤2: 新增批量查询运行状态API

**后端接口**:
```python
# src/api/routers/cameras.py

@router.post("/cameras/batch-status")
def batch_camera_status(
    camera_ids: List[str] = []
) -> Dict[str, Any]:
    """批量查询摄像头运行状态
    
    Args:
        camera_ids: 摄像头ID列表，为空则查询所有
    
    Returns:
        {
            "cam0": {"running": true, "pid": 3931},
            "vid1": {"running": false}
        }
    """
    pm = get_process_manager()
    
    # 获取所有摄像头ID
    if not camera_ids:
        cameras = _read_yaml(_cameras_path()).get("cameras", [])
        camera_ids = [str(c.get("id")) for c in cameras]
    
    # 批量查询状态
    result = {}
    for cam_id in camera_ids:
        status = pm.status(cam_id)
        result[cam_id] = {
            "running": status.get("running", False),
            "pid": status.get("pid", 0),
            "log": status.get("log", "")
        }
    
    return result
```

**前端API服务**:
```typescript
// frontend/src/api/camera.ts

export const cameraApi = {
  // ... 现有方法
  
  /**
   * 批量查询摄像头运行状态
   */
  async batchGetStatus(cameraIds?: string[]) {
    const response = await http.post('/cameras/batch-status', {
      camera_ids: cameraIds || []
    })
    return response.data
  }
}
```

### 步骤3: Store中实现状态合并

```typescript
// frontend/src/stores/camera.ts

import { ref, computed } from 'vue'
import { cameraApi, type Camera } from '@/api/camera'

export const useCameraStore = defineStore('camera', () => {
  const cameras = ref<Camera[]>([])
  const runtimeStatus = ref<Record<string, any>>({})
  
  // 获取摄像头列表（带运行状态）
  const camerasWithStatus = computed(() => {
    return cameras.value.map(cam => ({
      ...cam,
      runtime_status: runtimeStatus.value[cam.id] || {
        running: false,
        pid: 0
      }
    }))
  })
  
  // 刷新运行状态
  async function refreshRuntimeStatus() {
    try {
      const statuses = await cameraApi.batchGetStatus()
      runtimeStatus.value = statuses
    } catch (e: any) {
      console.error('刷新运行状态失败:', e)
    }
  }
  
  // 启动摄像头（改进版）
  async function startCamera(id: string) {
    loading.value = true
    error.value = ''
    
    try {
      // 1. 发送启动命令
      await cameraApi.startCamera(id)
      
      // 2. 等待1秒让进程启动
      await new Promise(resolve => setTimeout(resolve, 1000))
      
      // 3. 验证进程是否真正启动
      await refreshRuntimeStatus()
      
      const status = runtimeStatus.value[id]
      if (status?.running) {
        // 启动成功
        return { success: true, message: `摄像头已启动 (PID: ${status.pid})` }
      } else {
        // 启动失败
        throw new Error('进程未能成功启动，请查看日志')
      }
    } catch (e: any) {
      error.value = e.message || '启动摄像头失败'
      throw e
    } finally {
      loading.value = false
    }
  }
  
  return {
    cameras,
    camerasWithStatus,  // ← 新增：带状态的摄像头列表
    runtimeStatus,      // ← 新增：运行状态映射
    refreshRuntimeStatus, // ← 新增：刷新状态方法
    startCamera,        // ← 改进：带验证的启动
    // ... 其他方法
  }
})
```

### 步骤4: 修改CameraConfig.vue

```vue
<script setup lang="ts">
import { useCameraStore } from '@/stores/camera'

const cameraStore = useCameraStore()

// 使用带状态的摄像头列表
const filteredCameras = computed(() => {
  let data = cameraStore.camerasWithStatus  // ← 改为使用带状态的列表
  // ... 筛选逻辑
  return data
})

// 运行状态列（改进版）
const columns = [
  // ... 其他列
  {
    title: '运行状态',
    key: 'runtime_status',
    width: 180,
    render: (row: any) => {
      const isActive = row.active ?? row.enabled ?? true
      if (!isActive) {
        return h(NSpace, { vertical: true, size: 'small' }, {
          default: () => [
            h(NTag, { type: 'default', size: 'small' }, { 
              default: () => '🚫 禁止启动' 
            }),
            h(NText, { depth: 3, style: { fontSize: '11px' } }, {
              default: () => '(请先激活)'
            })
          ]
        })
      }
      
      // ✅ 实时查询状态
      const status = row.runtime_status
      if (status?.running) {
        return h(NSpace, { vertical: true, size: 'small' }, {
          default: () => [
            h(NTag, { type: 'success', size: 'small' }, { 
              default: () => '🟢 运行中' 
            }),
            h(NText, { depth: 3, style: { fontSize: '11px' } }, {
              default: () => `PID: ${status.pid || '-'}`
            })
          ]
        })
      } else {
        return h(NTag, { type: 'default', size: 'small' }, { 
          default: () => '⚪ 已停止' 
        })
      }
    }
  }
]

// 启动摄像头（改进版）
async function startCamera(id: string) {
  try {
    loading.value = true
    const result = await cameraStore.startCamera(id)
    message.success(result.message)  // ← 显示详细消息
  } catch (error: any) {
    message.error(error.message || '启动失败')
  } finally {
    loading.value = false
  }
}

// 定期刷新运行状态
function startStatusInterval() {
  if (statusInterval) window.clearInterval(statusInterval)
  statusInterval = window.setInterval(async () => {
    await cameraStore.refreshRuntimeStatus()  // ← 只刷新运行状态
  }, 5000)  // 5秒刷新一次
}

onMounted(async () => {
  await cameraStore.fetchCameras()
  await cameraStore.refreshRuntimeStatus()  // ← 初始化时查询状态
  if (autoRefresh.value) startStatusInterval()
})
</script>
```

---

## 📊 交互流程图

### 启动摄像头流程

```
用户点击"启动"
    ↓
前端: loading = true
    ↓
调用 startCamera(id)
    ↓
后端: 启动子进程
    ↓
返回启动命令结果
    ↓
前端: 等待1秒
    ↓
前端: 调用 refreshRuntimeStatus()
    ↓
后端: 查询进程状态
    ↓
返回真实运行状态
    ↓
前端判断:
├─ running=true  → message.success("已启动 PID: 3931")
└─ running=false → message.error("启动失败，请查看日志")
    ↓
前端: loading = false
    ↓
UI更新: 显示真实状态
```

### 状态刷新流程

```
定时器(5秒)
    ↓
调用 refreshRuntimeStatus()
    ↓
后端: 批量查询所有摄像头状态
    ↓
返回状态字典:
{
  "cam0": {"running": true, "pid": 3931},
  "vid1": {"running": false}
}
    ↓
前端: 更新 runtimeStatus
    ↓
computed: camerasWithStatus 自动重新计算
    ↓
UI: 表格自动更新显示
```

---

## 🎯 优化效果

### Before (优化前)

```
用户操作: 点击"启动"
系统响应: "摄像头启动成功" ✅
实际状态: 进程启动失败 ❌
界面显示: ⚪ 已停止 (静态)

❌ 用户困惑: 明明提示成功了，为什么还是"已停止"？
```

### After (优化后)

```
用户操作: 点击"启动"
系统响应: Loading... (1秒)
进程验证: 检查进程是否真正启动
  ├─ 成功: "摄像头已启动 (PID: 3931)" ✅
  └─ 失败: "启动失败，请查看日志" ⚠️
界面显示: 🟢 运行中 | PID: 3931 (实时)

✅ 用户体验: 清晰的反馈，准确的状态
```

---

## 🔄 自动刷新机制

### 刷新策略

| 触发时机 | 刷新内容 | 频率 |
|---------|----------|------|
| 页面加载 | 摄像头列表 + 运行状态 | 1次 |
| 定时刷新 | 仅运行状态 | 5秒 |
| 启动后 | 仅运行状态 | 立即+1秒后 |
| 停止后 | 仅运行状态 | 立即 |
| 手动刷新 | 摄像头列表 + 运行状态 | 按需 |

### 性能优化

1. **分离查询**: 配置和状态分开查询，减少不必要的请求
2. **批量查询**: 一次请求获取所有摄像头状态
3. **局部更新**: 只更新 `runtimeStatus`，不重新加载整个列表
4. **智能刷新**: 启动/停止后立即刷新，不等定时器

---

## 📝 API接口设计

### 新增接口

```http
POST /api/v1/cameras/batch-status
Content-Type: application/json

{
  "camera_ids": ["cam0", "vid1"]  // 可选，空则查询所有
}

Response:
{
  "cam0": {
    "running": true,
    "pid": 3931,
    "log": "/path/to/log"
  },
  "vid1": {
    "running": false,
    "pid": 0,
    "log": "/path/to/log"
  }
}
```

### 响应时间

- **单个查询**: ~10-20ms (读PID文件)
- **批量查询**: ~30-50ms (查询10个摄像头)
- **前端刷新**: ~100-150ms (网络+处理)

---

## 🎓 实施要点

### 关键改进

1. ✅ **真实状态**: 从进程管理器查询真实状态
2. ✅ **启动验证**: 启动后验证进程是否成功
3. ✅ **及时反馈**: 1秒后给出准确反馈
4. ✅ **实时更新**: 5秒自动刷新运行状态
5. ✅ **性能优化**: 批量查询，局部更新

### 用户体验改进

| 场景 | 优化前 | 优化后 |
|------|--------|--------|
| 启动成功 | "启动成功" (不准) | "已启动 PID: 3931" (准确) |
| 启动失败 | "启动成功" (误导) | "启动失败，请查看日志" (清晰) |
| 状态显示 | 静态"已停止" | 实时"运行中/已停止" |
| 进程信息 | 无 | 显示PID |
| 刷新频率 | 10秒 | 5秒 (更快) |

---

## 🚀 下一步优化

### 短期（本次实现）

- [x] 新增批量状态查询API
- [x] Store实现状态合并
- [x] 启动后验证进程
- [x] UI显示实时状态

### 中期（后续优化）

- [ ] WebSocket推送状态变化
- [ ] 显示更多运行信息（FPS、处理帧数）
- [ ] 状态变化动画效果
- [ ] 进程异常自动告警

### 长期（未来规划）

- [ ] 进程健康度监控
- [ ] 自动重启机制
- [ ] 性能趋势图表
- [ ] 智能诊断建议

---

## 📋 实施清单

- [ ] 后端: 新增 `batch-status` 接口
- [ ] 前端: 扩展 Camera 类型定义
- [ ] 前端: API服务添加 `batchGetStatus`
- [ ] Store: 实现 `runtimeStatus` 和 `refreshRuntimeStatus`
- [ ] Store: 改进 `startCamera` 方法（加验证）
- [ ] CameraConfig.vue: 使用 `camerasWithStatus`
- [ ] CameraConfig.vue: 更新运行状态列渲染
- [ ] CameraConfig.vue: 调整刷新策略
- [ ] 测试: 启动成功场景
- [ ] 测试: 启动失败场景
- [ ] 测试: 状态自动刷新
- [ ] 文档: 更新使用说明

---

**预估工作量**: 1-2小时  
**优先级**: 🔴 高（用户体验关键改进）  
**风险**: 🟢 低（向后兼容）  
**建议**: 立即实施

