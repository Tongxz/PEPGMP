# 项目开发规范

## ⚠️ 重要提醒：架构合规要求

**所有代码实现、功能改造、错误修复都必须符合当前最新的DDD架构要求。不符合架构要求的代码修改将被拒绝。**

详细规则请参考本文档的"架构合规规则"部分。

---

## 1. 目录结构规范

所有创建的文件都应该按照项目规范存放在对应的目录下：

### 核心目录（基于DDD架构）
- 所有的 Python 脚本都应该放在 `src/` 目录下，并按架构层次组织
  - `src/api/` - API层代码
  - `src/application/` - 应用层代码
  - `src/domain/` - 领域层代码（核心业务逻辑）
  - `src/infrastructure/` - 基础设施层代码
- 所有的测试脚本都应该放在 `tests/` 目录下，并按架构层次组织
- 所有的配置文件都应该放在 `config/` 目录下
- 所有的文档文件都应该放在 `docs/` 目录下

### 资源和数据目录
- 所有的资源文件都应该放在 `resources/` 目录下（如需要）
- 所有的模型文件都应该放在 `models/` 目录下（AI模型文件）
- 所有的日志文件都应该放在 `logs/` 目录下
- 所有的临时文件都应该放在 `temp/` 或 `output/` 目录下
- 所有的测试数据都存放在 `tests/fixtures/` 目录下
- 数据集存放在 `datasets/` 目录下（如需要）

### 环境和部署目录
- 所有的虚拟环境都应该放在 `venv/` 目录下
- 所有的环境变量配置文件都应该放在 `env/` 目录下
- 部署相关文件放在 `deployment/` 目录下
- 开发脚本放在 `scripts/` 目录下

### src/ 目录结构（基于DDD架构）

```
src/
├── api/                    # API层 (Interfaces)
│   ├── routers/           # API路由
│   ├── middleware/        # 中间件
│   └── utils/             # API工具函数
├── application/            # 应用层 (Application)
│   └── ...                # 用例编排、DTO转换、事务协调
├── domain/                 # 领域层 (Domain) - 核心业务逻辑
│   ├── entities/          # 领域实体
│   ├── value_objects/     # 值对象
│   ├── services/          # 领域服务
│   ├── repositories/      # 仓储接口（抽象）
│   └── events/            # 领域事件
├── infrastructure/         # 基础设施层 (Infrastructure)
│   ├── repositories/      # 仓储实现（PostgreSQL、Redis等）
│   └── database/          # 数据库连接和迁移
├── core/                   # 核心功能模块（检测、跟踪等）
├── detection/              # 检测相关实现
├── strategies/             # 策略模式实现（检测器、跟踪器策略）
├── services/               # 应用服务层（部分遗留服务）
├── utils/                  # 通用工具函数
├── config/                 # 配置管理
├── database/               # 数据库相关（连接池等）
├── security/               # 安全相关
├── monitoring/             # 监控和指标收集
├── optimization/           # 性能优化相关
├── workflow/               # 工作流引擎
├── container/              # 依赖注入容器
└── interfaces/             # 接口定义（检测器、跟踪器等抽象接口）
```

**架构层次说明**:
- **API层** (`src/api/`): HTTP请求处理、参数验证、响应格式化
- **应用层** (`src/application/`): 用例编排、DTO转换、事务协调
- **领域层** (`src/domain/`): 业务逻辑、领域规则、领域模型（核心）
- **基础设施层** (`src/infrastructure/`): 仓储实现、外部服务集成、技术实现

### tests/ 目录结构

```
tests/
├── unit/                  # 单元测试
│   ├── domain/           # 领域层单元测试
│   ├── infrastructure/   # 基础设施层单元测试
│   └── ...               # 其他单元测试
├── integration/          # 集成测试
│   └── ...               # API集成测试、端到端测试
├── fixtures/             # 测试数据和固定装置
│   ├── images/           # 测试图像
│   └── videos/           # 测试视频
└── conftest.py           # pytest 配置和共享fixtures
```

**测试组织原则**:
- 单元测试按架构层次组织（`tests/unit/domain/`、`tests/unit/infrastructure/`等）
- 集成测试放在 `tests/integration/` 目录
- 测试数据统一放在 `tests/fixtures/` 目录

## 2. 文件命名规范

### Python 文件命名
- 使用小写字母和下划线：`my_module.py`
- 测试文件以 `test_` 开头：`test_my_module.py`
- 类名使用 PascalCase：`class MyClass`
- 函数和变量使用 snake_case：`def my_function()`

### 领域层文件命名规范
- **实体文件**: 使用实体名称，如 `alert.py`、`detection_record.py`
- **值对象文件**: 使用值对象名称，如 `bounding_box.py`、`confidence.py`
- **领域服务文件**: 使用 `{domain}_service.py` 格式，如 `alert_service.py`、`detection_service.py`
- **仓储接口文件**: 使用 `{entity}_repository.py` 格式，如 `alert_repository.py`、`detection_repository.py`
- **领域事件文件**: 使用 `{domain}_events.py` 格式，如 `detection_events.py`

### 基础设施层文件命名规范
- **仓储实现文件**: 使用 `postgresql_{entity}_repository.py` 格式，如 `postgresql_alert_repository.py`
- **数据库相关文件**: 使用描述性名称，如 `connection.py`、`migrations.py`

### 配置文件命名
- YAML 配置文件：`config_name.yaml`
- JSON 配置文件：`config_name.json`
- 环境变量文件：`.env`, `.env.local`, `.env.production`

### 文档文件命名
- README 文件：`README.md`, `README_FEATURE.md`
- 架构文档：`SYSTEM_ARCHITECTURE.md`, `ARCHITECTURE_COMPLIANCE_*.md`
- 技术文档使用描述性名称：`技术方案.md`, `部署指南.md`
- 使用大写字母和下划线：`DATABASE_MIGRATION.md`, `API_DESIGN.md`

## 3. 代码风格规范

### Python 代码风格
- 遵循 PEP 8 标准
- 使用 4 个空格缩进，不使用 Tab
- 行长度限制为 88 字符（Black 格式化器标准）
- 使用类型注解：`def function(param: str) -> int:`

### 模块组织规范

#### `__init__.py` 文件规范
- 每个包目录都应包含 `__init__.py` 文件
- `__init__.py` 应该导出该包对外提供的公共接口
- 使用 `__all__` 明确声明公共API

**示例 - 领域层 `__init__.py`**:
```python
"""
领域层
包含业务逻辑、实体、值对象、领域服务等
"""

from .entities.detection_record import DetectionRecord
from .entities.camera import Camera
from .services.detection_service import DetectionService
from .repositories.detection_repository import IDetectionRepository

__all__ = [
    "DetectionRecord",
    "Camera",
    "DetectionService",
    "IDetectionRepository",
]
```

**示例 - 实体子包 `__init__.py`**:
```python
"""
领域实体
包含业务核心实体
"""

from .detection_record import DetectionRecord
from .camera import Camera
from .detected_object import DetectedObject

__all__ = ["DetectionRecord", "Camera", "DetectedObject"]
```

#### 模块导入顺序
1. 标准库导入
2. 第三方库导入
3. 本地模块导入（按架构层次分组）
   - 领域层导入
   - 基础设施层导入
   - 工具类导入

#### 循环依赖预防
- 领域层不能依赖基础设施层
- 基础设施层只能实现领域层定义的接口
- 使用依赖注入避免循环依赖

### 导入规范
```python
# 标准库导入
import os
import sys
from typing import List, Dict, Optional

# 第三方库导入
import cv2
import numpy as np
import torch

# 本地模块导入（按架构层次组织）
# API层导入
from src.api.middleware.error_middleware import ErrorHandlingMiddleware

# 应用层导入
from src.application.detection_application_service import DetectionApplicationService

# 领域层导入
from src.domain.entities.detection_record import DetectionRecord
from src.domain.services.detection_service import DetectionService
from src.domain.repositories.detection_repository import IDetectionRepository

# 基础设施层导入
from src.infrastructure.repositories.postgresql_detection_repository import PostgreSQLDetectionRepository

# 工具类导入
from src.utils.logger import get_logger
from src.core.detector import HumanDetector
```

### 日志规范

#### 日志工具使用
- 统一使用 `src.utils.logger.get_logger()` 获取日志记录器
- 日志文件统一存放在 `logs/` 目录下
- 使用模块名作为日志记录器名称：`logger = logging.getLogger(__name__)`

#### 日志级别使用
- **DEBUG**: 详细调试信息，开发时使用，生产环境通常关闭
- **INFO**: 一般信息，程序正常运行状态（服务启动/停止、连接建立/断开、重要操作完成）
- **WARNING**: 警告信息，潜在问题但不影响功能（配置缺失、性能下降、资源使用率高）
- **ERROR**: 错误信息，功能失败或异常（连接失败、操作失败、异常捕获）

#### 日志输出频率规范
- **高频操作**（每帧或每N帧）：每30-100帧记录一次摘要
  - 视频帧推送：每30帧记录一次（INFO级别）
  - Redis接收帧：每30帧记录一次（INFO级别）
  - 无客户端连接：每100帧记录一次（DEBUG级别）
- **中频操作**（周期性）：每5-10分钟或重要状态变化
  - 性能统计：每5-10分钟
  - 状态检查：每30秒-1分钟
- **低频操作**（事件驱动）：每次发生都记录
  - 连接/断开：每次（INFO级别）
  - 错误/警告：每次（WARNING/ERROR级别）
  - 服务启动/停止：每次（INFO级别）

#### 日志格式规范
- 使用标准格式：`"%(asctime)s - %(name)s - %(levelname)s - %(message)s"`
- 时间格式：`"%Y-%m-%d %H:%M:%S"`
- 日志消息应包含足够的上下文信息（如camera_id、frame_id等）

#### 日志记录示例
```python
# 标准库导入
import logging

# 获取日志记录器
logger = logging.getLogger(__name__)

# API层日志示例
@router.get("/detection/{camera_id}")
async def get_detection_records(camera_id: str):
    try:
        logger.info(f"获取检测记录: camera_id={camera_id}")
        # ... 业务逻辑
        logger.debug(f"查询完成: camera_id={camera_id}, count={len(records)}")
        return records
    except Exception as e:
        logger.error(f"获取检测记录失败: camera_id={camera_id}, error={e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

# 领域服务日志示例
class DetectionService:
    async def process_detection(self, record: DetectionRecord):
        logger.info(f"处理检测记录: camera_id={record.camera_id}, frame_id={record.frame_id}")
        # ... 业务逻辑
        logger.debug(f"检测完成: 对象数={len(record.objects)}, 违规数={len(violations)}")

# 基础设施层日志示例（仓储实现）
class PostgreSQLDetectionRepository:
    async def save(self, record: DetectionRecord):
        try:
            logger.debug(f"保存检测记录: camera_id={record.camera_id}, id={record.id}")
            # ... 数据库操作
            logger.info(f"检测记录已保存: id={record.id}")
        except Exception as e:
            logger.error(f"保存检测记录失败: camera_id={record.camera_id}, error={e}", exc_info=True)
            raise RepositoryError(f"保存失败: {e}")
```

#### 日志性能考虑
- 避免在循环中频繁输出日志，使用摘要日志（每N次记录一次）
- 避免在日志中执行复杂操作或格式化大对象
- 使用条件日志（`if logger.isEnabledFor(logging.DEBUG):`）减少不必要的字符串格式化

#### 生产环境日志配置
- **日志级别**: INFO（关闭DEBUG）
- **日志轮转**: 单个文件最大100MB，保留最近10个文件
- **日志压缩**: 旧日志文件自动压缩

### 注释和文档字符串

#### API层方法示例
```python
@router.get("/detection/{camera_id}")
async def get_detection_records(
    camera_id: str,
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None
) -> List[DetectionRecordDTO]:
    """
    获取检测记录列表

    Args:
        camera_id: 摄像头ID
        start_time: 开始时间（可选）
        end_time: 结束时间（可选）

    Returns:
        检测记录DTO列表

    Raises:
        HTTPException: 当摄像头不存在或查询失败时
    """
    pass
```

#### 领域服务方法示例
```python
class DetectionService:
    async def get_detection_history(
        self,
        camera_id: str,
        start_time: datetime,
        end_time: datetime
    ) -> List[DetectionRecord]:
        """
        获取检测历史记录（领域服务）

        Args:
            camera_id: 摄像头ID（值对象或字符串）
            start_time: 开始时间
            end_time: 结束时间

        Returns:
            检测记录实体列表

        Raises:
            DomainException: 当领域规则验证失败时
        """
        pass
```

#### 仓储接口方法示例
```python
class IDetectionRepository(ABC):
    @abstractmethod
    async def find_by_time_range(
        self,
        camera_id: str,
        start_time: datetime,
        end_time: datetime
    ) -> List[DetectionRecord]:
        """
        根据时间范围查询检测记录（仓储接口）

        Args:
            camera_id: 摄像头ID
            start_time: 开始时间
            end_time: 结束时间

        Returns:
            检测记录实体列表
        """
        pass
```

---

## 🏗️ 架构合规规则（强制遵守 - 优先级最高）

### ⚠️ 核心原则（必须严格遵守）

**所有代码实现、功能改造、错误修复都必须符合当前最新的DDD架构要求。**

**违反此规则的代码修改将被拒绝。**

### 📋 架构合规检查

在进行任何代码修改时，必须首先确保：
1. ✅ 符合当前最新的DDD架构要求
2. ✅ 无回退逻辑（fallback）
3. ✅ 无灰度控制参数
4. ✅ 无跨层调用
5. ✅ 通过仓储接口访问数据

### 架构层次（必须严格遵守）

```
API层 (Interfaces) → 应用层 (Application) → 领域层 (Domain) → 基础设施层 (Infrastructure)
```

#### API层 (`src/api/`)
- **职责**: HTTP请求处理、参数验证、响应格式化
- **禁止**:
  - ❌ 直接访问数据库连接池
  - ❌ 直接调用仓储实现类
  - ❌ 包含业务逻辑
  - ❌ **回退逻辑（fallback）** - 绝对禁止
  - ❌ **灰度控制参数（`force_domain`、`should_use_domain`）** - 绝对禁止
- **必须**:
  - ✅ 通过领域服务或应用服务访问数据
  - ✅ 统一的错误处理（HTTP异常）
  - ✅ 如果服务不可用，返回明确的HTTP 503错误

#### 领域层 (`src/domain/`)
- **职责**: 业务逻辑、领域规则、领域模型
- **禁止**:
  - ❌ 依赖基础设施层
  - ❌ 直接访问数据库

#### 基础设施层 (`src/infrastructure/`)
- **职责**: 仓储实现、外部服务集成、技术实现
- **必须**:
  - ✅ 实现领域层定义的仓储接口
  - ✅ 只负责技术实现，不包含业务逻辑

### 🚫 绝对禁止的事项

#### 1. 禁止回退逻辑（Fallback）

**原因**: 回退逻辑会导致结果不可预期，违反架构原则。

**禁止的模式**:
```python
# ❌ 禁止：回退到旧实现
try:
    result = await domain_service.get_data()
    return result
except Exception:
    return old_implementation()  # 禁止

# ❌ 禁止：回退到直接数据库查询
try:
    result = await domain_service.get_data()
except Exception:
    async with db.pool.acquire() as conn:  # 禁止
        return await conn.fetch(...)
```

**正确的做法**:
```python
# ✅ 正确：统一使用领域服务，失败时返回明确的HTTP错误
def _ensure_domain_service():
    if get_domain_service is None:
        raise HTTPException(status_code=503, detail="领域服务不可用")
    return get_domain_service()

@router.get("/endpoint")
async def get_data():
    try:
        domain_service = _ensure_domain_service()
        return await domain_service.get_data()
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"获取数据失败: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"获取数据失败: {str(e)}")
```

#### 2. 禁止灰度控制

**原因**: 灰度控制会在代码中留下多条执行路径，增加维护成本。

**禁止的模式**:
```python
# ❌ 禁止：灰度控制参数
async def endpoint(force_domain: Optional[bool] = Query(None)):
    if should_use_domain(force_domain):  # 禁止
        return await new_service.get_data()
    return await old_service.get_data()  # 禁止
```

#### 3. 禁止跨层调用

**禁止**: API层直接访问数据库、领域层依赖基础设施

### ✅ 必须遵守的原则

1. **SOLID原则**: 单一职责、开闭原则、里氏替换、接口隔离、依赖倒置
2. **依赖方向**: API层 → 应用层 → 领域层 ← 基础设施层
3. **数据访问**: 所有数据访问必须通过仓储接口
4. **错误处理**: 统一的HTTP异常处理，不返回默认值

### 📝 代码审查检查清单

在提交代码前，请确保：
- [ ] **无回退逻辑**: 代码中没有 `try-except` 回退到旧实现
- [ ] **无灰度控制**: 代码中没有 `should_use_domain` 或 `force_domain` 参数
- [ ] **无跨层调用**: API层不直接访问数据库，领域层不依赖基础设施
- [ ] **统一错误处理**: 使用HTTP异常，不返回默认值
- [ ] **通过仓储接口**: 所有数据访问通过仓储接口

**重要**: 任何不符合架构要求的代码修改都将被拒绝。

参考文档: `docs/SYSTEM_ARCHITECTURE.md`, `docs/ARCHITECTURE_COMPLIANCE_NO_FALLBACK.md`
